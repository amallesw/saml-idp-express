import { PubKeyInfo } from './cert';
import { WrapError } from './response';
declare const _default: {
    parseMetadata: (idpMeta: string, validateOpts: any) => Promise<Record<string, any>>;
    createIdPMetadataXML: ({ ssoUrl, entityId, x509cert, wantAuthnRequestsSigned, }: {
        ssoUrl: string;
        entityId: string;
        x509cert: string;
        wantAuthnRequestsSigned: boolean;
    }) => string;
    createSPMetadataXML: ({ entityId, publicKeyString, acsUrl, encryption, }: {
        entityId: string;
        publicKeyString: string;
        acsUrl: string;
        encryption: boolean;
    }) => string;
    createSAMLResponse: ({ audience, issuer, acsUrl, claims, requestId, privateKey, publicKey, flattenArray, }: {
        audience: string;
        issuer: string;
        acsUrl: string;
        claims: Record<string, any>;
        requestId: string;
        privateKey: string;
        publicKey: string;
        flattenArray?: boolean | undefined;
    }) => Promise<string>;
    request: ({ ssoUrl, entityID, callbackUrl, isPassive, forceAuthn, identifierFormat, providerName, signingKey, publicKey, }: import("./typings").SAMLReq) => {
        id: string;
        request: string;
    };
    parseSAMLRequest: (rawRequest: string, isPost?: boolean) => Promise<{
        id: any;
        acsUrl: any;
        providerName: any;
        audience: any;
        publicKey: any;
    }>;
    decodeBase64: (string: string, isDeflated: boolean) => Promise<string>;
    parse: (rawAssertion: string) => Promise<import("./typings").SAMLProfile>;
    validate: (rawAssertion: string, options: any) => Promise<import("./typings").SAMLProfile>;
    PubKeyInfo: typeof PubKeyInfo;
    certToPEM: (cert: any) => any;
    stripCertHeaderAndFooter: (cert: string) => string;
    createPostForm: (postUrl: string, params: {
        name: string;
        value: string;
    }[]) => string;
    sign: (xml: string, signingKey: string, publicKey: string, xPath: string) => string;
    hasValidSignature: (xml: any, cert: any, certThumbprint: any) => {
        valid: any;
        calculatedThumbprint: any;
        id: any;
    };
    validateSignature: (xml: any, cert: any, certThumbprint: any) => any;
    decryptXml: (entireXML: string, options: any) => any;
    parseIssuer: (rawAssertion: any) => string | undefined;
    WrapError: typeof WrapError;
    parseLogoutResponse: (rawResponse: string) => Promise<{
        id: string;
        issuer: string;
        status: string;
        destination: string;
        inResponseTo: string;
    }>;
    createLogoutRequest: ({ nameId, providerName, sloUrl, }: {
        nameId: string;
        providerName: string;
        sloUrl: string;
    }) => {
        id: string;
        xml: string;
    };
};
export default _default;
