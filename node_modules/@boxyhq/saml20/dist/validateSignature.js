"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.certToPEM = exports.validateSignature = exports.hasValidSignature = void 0;
const xml_crypto_1 = require("xml-crypto");
const xpath_1 = require("xpath");
const utils_1 = require("./utils");
const utils_2 = require("./utils");
const isMultiCert = (cert) => {
    return cert.indexOf(',') !== -1;
};
const certToPEM = (cert) => {
    if (cert.indexOf('BEGIN CERTIFICATE') === -1 && cert.indexOf('END CERTIFICATE') === -1) {
        cert = cert.match(/.{1,64}/g).join('\n');
        cert = '-----BEGIN CERTIFICATE-----\n' + cert;
        cert = cert + '\n-----END CERTIFICATE-----\n';
        return cert;
    }
    else {
        return cert;
    }
};
exports.certToPEM = certToPEM;
const hasValidSignature = (xml, cert, certThumbprint) => {
    let res = _hasValidSignature(xml, cert, certThumbprint);
    // sanitize and validate if validation failed first time
    if (!res.valid) {
        xml = xml.replace(/&#x(d|D);/gi, '');
        res = _hasValidSignature(xml, cert, certThumbprint);
    }
    return res;
};
exports.hasValidSignature = hasValidSignature;
const _hasValidSignature = (xml, cert, certThumbprint) => {
    var _a, _b, _c, _d;
    const doc = (0, utils_2.parseFromString)(xml);
    let signature = ((_a = (0, xpath_1.select)("/*/*/*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']", doc)) === null || _a === void 0 ? void 0 : _a[0]) ||
        ((_b = (0, xpath_1.select)("/*/*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']", doc)) === null || _b === void 0 ? void 0 : _b[0]) ||
        ((_c = (0, xpath_1.select)("/*/*/*/*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']", doc)) === null || _c === void 0 ? void 0 : _c[0]);
    if (!signature) {
        signature = (_d = (0, xpath_1.select)("//*[local-name(.)='Signature']", doc)) === null || _d === void 0 ? void 0 : _d[0];
    }
    const signed = new xml_crypto_1.SignedXml({
        idAttribute: 'AssertionID',
    });
    signed.loadSignature(signature.toString());
    let valid;
    let id, calculatedThumbprint;
    // Check if cert contains multiple
    // Load each cert and run checkSignature
    if (cert && isMultiCert(cert)) {
        const _certs = cert.split(',');
        for (const _cert of _certs) {
            signed.getCertFromKeyInfo = () => {
                return certToPEM(_cert);
            };
            try {
                valid = signed.checkSignature(xml);
            }
            catch (err) {
                //noop
            }
            if (valid) {
                break;
            }
        }
        if (!valid) {
            throw new Error('invalid signature: Failed to verify signature against all the certificates provided.');
        }
    }
    else {
        signed.getCertFromKeyInfo = function getKey(keyInfo) {
            if (certThumbprint) {
                const embeddedCert = keyInfo.childNodes[0].ownerDocument.getElementsByTagNameNS('http://www.w3.org/2000/09/xmldsig#', 'X509Certificate');
                if (embeddedCert.length > 0) {
                    const base64cer = embeddedCert[0].firstChild.toString();
                    calculatedThumbprint = (0, utils_1.thumbprint)(base64cer);
                    return certToPEM(base64cer);
                }
            }
            return certToPEM(cert);
        };
        valid = signed.checkSignature(xml);
    }
    if (valid) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const uri = signed.references[0].uri;
        id = uri[0] === '#' ? uri.substring(1) : uri;
    }
    return {
        valid,
        calculatedThumbprint,
        id,
    };
};
const validateSignature = (xml, cert, certThumbprint) => {
    if (cert && certThumbprint) {
        throw new Error('You should provide either cert or certThumbprint, not both');
    }
    const { valid, calculatedThumbprint, id } = hasValidSignature(xml, cert, certThumbprint);
    if (valid) {
        if (certThumbprint) {
            const thumbprints = certThumbprint.split(',');
            if (thumbprints.includes(calculatedThumbprint)) {
                return id;
            }
        }
        if (cert) {
            return id;
        }
    }
};
exports.validateSignature = validateSignature;
