"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSPMetadataXML = exports.createIdPMetadataXML = exports.parseMetadata = void 0;
const utils_1 = require("./utils");
const utils_2 = require("./utils");
const cert_1 = require("./cert");
const crypto_1 = __importDefault(require("crypto"));
const xml2js_1 = __importDefault(require("xml2js"));
const xmlbuilder_1 = __importDefault(require("xmlbuilder"));
const BEGIN = '-----BEGIN CERTIFICATE-----';
const END = '-----END CERTIFICATE-----';
const parseMetadata = (idpMeta, validateOpts) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
        // Some Providers do not escape the & character in the metadata, for now these have been encountered in errorURL
        idpMeta = idpMeta.replace(/errorURL=".*?"/g, '');
        xml2js_1.default.parseString(idpMeta, {
            tagNameProcessors: [xml2js_1.default.processors.stripPrefix],
            strict: true,
        }, (err, res) => {
            var _a, _b, _c;
            if (err) {
                reject(err);
                return;
            }
            const entityID = (0, utils_1.getAttribute)(res, 'EntityDescriptor.$.entityID');
            let X509Certificates = [];
            const X509CertificatesWithoutSigningAttr = [];
            let ssoPostUrl = null;
            let ssoRedirectUrl = null;
            let loginType = 'idp';
            let sloRedirectUrl = null;
            let sloPostUrl = null;
            let ssoDes = (0, utils_1.getAttribute)(res, 'EntityDescriptor.IDPSSODescriptor', null);
            if (!ssoDes) {
                ssoDes = (0, utils_1.getAttribute)(res, 'EntityDescriptor.SPSSODescriptor', []);
                if (ssoDes.length > 0) {
                    loginType = 'sp';
                }
            }
            for (const ssoDesRec of ssoDes) {
                const keyDes = ssoDesRec['KeyDescriptor'];
                for (const keyDesRec of keyDes) {
                    const ki = (_a = keyDesRec['KeyInfo']) === null || _a === void 0 ? void 0 : _a[0];
                    const cd = (_b = ki === null || ki === void 0 ? void 0 : ki['X509Data']) === null || _b === void 0 ? void 0 : _b[0];
                    const x509cert = (_c = cd === null || cd === void 0 ? void 0 : cd['X509Certificate']) === null || _c === void 0 ? void 0 : _c[0];
                    if (keyDesRec['$'] && keyDesRec['$'].use === 'signing') {
                        x509cert && X509Certificates.push(x509cert);
                    }
                    else {
                        x509cert && X509CertificatesWithoutSigningAttr.push(x509cert);
                    }
                }
                const ssoSvc = ssoDesRec['SingleSignOnService'] || ssoDesRec['AssertionConsumerService'] || [];
                for (const ssoSvcRec of ssoSvc) {
                    if ((0, utils_1.getAttribute)(ssoSvcRec, '$.Binding', '').endsWith('HTTP-POST')) {
                        ssoPostUrl = (0, utils_1.getAttribute)(ssoSvcRec, '$.Location');
                    }
                    else if ((0, utils_1.getAttribute)(ssoSvcRec, '$.Binding', '').endsWith('HTTP-Redirect')) {
                        ssoRedirectUrl = (0, utils_1.getAttribute)(ssoSvcRec, '$.Location');
                    }
                }
                const sloSvc = ssoDesRec['SingleLogoutService'] || [];
                for (const sloSvcRec of sloSvc) {
                    if ((0, utils_1.getAttribute)(sloSvcRec, '$.Binding', '').endsWith('HTTP-Redirect')) {
                        sloRedirectUrl = (0, utils_1.getAttribute)(sloSvcRec, '$.Location');
                    }
                    else if ((0, utils_1.getAttribute)(sloSvcRec, '$.Binding', '').endsWith('HTTP-POST')) {
                        sloPostUrl = (0, utils_1.getAttribute)(sloSvcRec, '$.Location');
                    }
                }
                if (validateOpts === null || validateOpts === void 0 ? void 0 : validateOpts.validateNameIDFormat) {
                    let validNameIDFormat = false;
                    const nameIDFormats = ssoDesRec['NameIDFormat'] || [];
                    for (const nameIDFormat of nameIDFormats) {
                        if ((validateOpts === null || validateOpts === void 0 ? void 0 : validateOpts.validateNameIDFormat) === nameIDFormat) {
                            validNameIDFormat = true;
                        }
                    }
                    if (!validNameIDFormat) {
                        reject(new Error(`Invalid nameIDFormat. Please set 'Name ID Format' to ${validateOpts === null || validateOpts === void 0 ? void 0 : validateOpts.nameIDFormat}`));
                        return;
                    }
                }
            }
            if (X509Certificates.length === 0) {
                if (X509CertificatesWithoutSigningAttr.length !== 0) {
                    X509Certificates = X509CertificatesWithoutSigningAttr;
                }
                else {
                    reject(new Error(`Could not find X509Certificate in the IdP metadata.`));
                }
            }
            const ret = {
                sso: {},
                slo: {},
            };
            if (entityID) {
                ret.entityID = entityID;
            }
            const tPrints = [];
            const validTos = [];
            for (const X509Certificate of X509Certificates) {
                tPrints.push((0, utils_2.thumbprint)(X509Certificate));
                /**
                 * new crypto.X509Certificate fails with the X509Certificate cert without
                 * -----BEGIN CERTIFICATE-----
                 * and
                 * -----END CERTIFICATE-----
                 */
                let vt = '';
                if (X509Certificate.indexOf(BEGIN) != -1 && X509Certificate.indexOf(END) != -1) {
                    const { validTo } = new crypto_1.default.X509Certificate(X509Certificate.trim());
                    vt = validTo;
                }
                else if (X509Certificate.indexOf(BEGIN) == -1 && X509Certificate.indexOf(END) != -1) {
                    /**
                     * Prefixing -----BEGIN CERTIFICATE-----
                     */
                    const { validTo } = new crypto_1.default.X509Certificate(`${BEGIN}\n${X509Certificate.trim()}`);
                    vt = validTo;
                }
                else if (X509Certificate.indexOf(BEGIN) != -1 && X509Certificate.indexOf(END) == -1) {
                    /**
                     * Suffixing -----END CERTIFICATE-----
                     */
                    const { validTo } = new crypto_1.default.X509Certificate(`${X509Certificate.trim()}\n${END}`);
                    vt = validTo;
                }
                else {
                    /**
                     * Prefixing -----BEGIN CERTIFICATE----- and suffixing -----END CERTIFICATE-----
                     */
                    const { validTo } = new crypto_1.default.X509Certificate(`${BEGIN}\n${X509Certificate.trim()}\n${END}`);
                    vt = validTo;
                }
                validTos.push(vt);
            }
            if (X509Certificates.length > 0) {
                ret.publicKey = X509Certificates.map((_) => _.trim()).join(',');
            }
            if (tPrints.length > 0) {
                ret.thumbprint = tPrints.join(',');
            }
            if (validTos.length > 0) {
                ret.validTo = validTos.join(',');
            }
            if (ssoPostUrl) {
                ret.sso.postUrl = ssoPostUrl;
            }
            if (ssoRedirectUrl) {
                ret.sso.redirectUrl = ssoRedirectUrl;
            }
            if (sloRedirectUrl) {
                ret.slo.redirectUrl = sloRedirectUrl;
            }
            if (sloPostUrl) {
                ret.slo.postUrl = sloPostUrl;
            }
            ret.loginType = loginType;
            resolve(ret);
        });
    });
});
exports.parseMetadata = parseMetadata;
const createIdPMetadataXML = ({ ssoUrl, entityId, x509cert, wantAuthnRequestsSigned, }) => {
    x509cert = (0, cert_1.stripCertHeaderAndFooter)(x509cert);
    const today = new Date();
    const nodes = {
        'md:EntityDescriptor': {
            '@xmlns:md': 'urn:oasis:names:tc:SAML:2.0:metadata',
            '@entityID': entityId,
            '@validUntil': new Date(today.setFullYear(today.getFullYear() + 10)).toISOString(),
            'md:IDPSSODescriptor': {
                '@WantAuthnRequestsSigned': wantAuthnRequestsSigned,
                '@protocolSupportEnumeration': 'urn:oasis:names:tc:SAML:2.0:protocol',
                'md:KeyDescriptor': {
                    '@use': 'signing',
                    'ds:KeyInfo': {
                        '@xmlns:ds': 'http://www.w3.org/2000/09/xmldsig#',
                        'ds:X509Data': {
                            'ds:X509Certificate': {
                                '#text': x509cert,
                            },
                        },
                    },
                },
                'md:NameIDFormat': {
                    '#text': 'urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress',
                },
                'md:SingleSignOnService': [
                    {
                        '@Binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect',
                        '@Location': ssoUrl,
                    },
                    {
                        '@Binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST',
                        '@Location': ssoUrl,
                    },
                ],
            },
        },
    };
    return xmlbuilder_1.default.create(nodes, { encoding: 'UTF-8', standalone: false }).end({ pretty: true });
};
exports.createIdPMetadataXML = createIdPMetadataXML;
const createSPMetadataXML = ({ entityId, publicKeyString, acsUrl, encryption, }) => {
    const today = new Date();
    const keyDescriptor = [
        {
            '@use': 'signing',
            'ds:KeyInfo': {
                '@xmlns:ds': 'http://www.w3.org/2000/09/xmldsig#',
                'ds:X509Data': {
                    'ds:X509Certificate': {
                        '#text': publicKeyString,
                    },
                },
            },
        },
    ];
    if (encryption) {
        keyDescriptor.push({
            '@use': 'encryption',
            'ds:KeyInfo': {
                '@xmlns:ds': 'http://www.w3.org/2000/09/xmldsig#',
                'ds:X509Data': {
                    'ds:X509Certificate': {
                        '#text': publicKeyString,
                    },
                },
            },
            'md:EncryptionMethod': {
                '@Algorithm': 'http://www.w3.org/2001/04/xmlenc#aes256-cbc',
            },
        });
    }
    const nodes = {
        'md:EntityDescriptor': {
            '@xmlns:md': 'urn:oasis:names:tc:SAML:2.0:metadata',
            '@entityID': entityId,
            '@validUntil': new Date(today.setFullYear(today.getFullYear() + 10)).toISOString(),
            'md:SPSSODescriptor': {
                //'@WantAuthnRequestsSigned': true,
                '@protocolSupportEnumeration': 'urn:oasis:names:tc:SAML:2.0:protocol',
                'md:KeyDescriptor': keyDescriptor,
                'md:NameIDFormat': {
                    '#text': 'urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress',
                },
                'md:AssertionConsumerService': {
                    '@index': 1,
                    '@Binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST',
                    '@Location': acsUrl,
                },
            },
        },
    };
    return xmlbuilder_1.default.create(nodes, { encoding: 'UTF-8', standalone: false }).end({ pretty: true });
};
exports.createSPMetadataXML = createSPMetadataXML;
