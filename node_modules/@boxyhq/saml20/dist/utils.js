"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAttribute = exports.thumbprint = exports.parseFromString = void 0;
const xmldom_1 = require("@xmldom/xmldom");
const crypto_1 = __importDefault(require("crypto"));
const countRootNodes = (xmlDoc) => {
    const rootNodes = Array.from(xmlDoc.childNodes).filter((n) => n.tagName != null && n.childNodes != null);
    return rootNodes.length;
};
const parseFromString = (xmlString) => {
    const errors = {};
    let multiRootErrFound = false;
    const errorHandler = (key, msg) => {
        if (!errors[key])
            errors[key] = [];
        if (msg.indexOf('Only one element can be added and only after doctype')) {
            if (!multiRootErrFound) {
                multiRootErrFound = true;
                errors[key].push(msg);
            }
        }
        else {
            errors[key].push(msg);
        }
    };
    const xml = new xmldom_1.DOMParser({ errorHandler }).parseFromString(xmlString);
    if (multiRootErrFound) {
        throw new Error('multirooted xml not allowed.');
    }
    else if (Object.keys(errors).length > 0) {
        throw new Error('Invalid XML.');
    }
    const rootNodeCount = countRootNodes(xml);
    if (rootNodeCount > 1) {
        throw new Error('multirooted xml not allowed.');
    }
    if (rootNodeCount === 0) {
        throw new Error('Invalid assertion.');
    }
    return xml;
};
exports.parseFromString = parseFromString;
const thumbprint = (cert) => {
    const shasum = crypto_1.default.createHash('sha1');
    const bin = Buffer.from(cert, 'base64').toString('binary');
    shasum.update(bin);
    return shasum.digest('hex');
};
exports.thumbprint = thumbprint;
const getAttribute = (value, path, defaultValue) => {
    const segments = path.split(/[\.\[\]]/g); // eslint-disable-line no-useless-escape
    let current = value;
    for (const key of segments) {
        if (current === null)
            return defaultValue;
        if (current === undefined)
            return defaultValue;
        const dequoted = key.replace(/['"]/g, '');
        if (dequoted.trim() === '')
            continue;
        current = current[dequoted];
    }
    if (current === undefined)
        return defaultValue;
    return current;
};
exports.getAttribute = getAttribute;
